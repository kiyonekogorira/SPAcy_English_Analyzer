# 文型判別ロジックの比較検討 (jissou-jyoukyou_05)

## 1. はじめに

本ドキュメントでは、現在の`spacy_app/app.py`に実装されている英文の文型判別ロジックと、より厳密な判別を目指す上での理想的なロジックを比較検討します。特に、spaCyの依存関係解析結果をどのように解釈し、各文型にマッピングしているかに焦点を当てます。

## 2. 現在のロジックの概要

`app.py`における文型判別は、主に以下の2つの関数によって行われます。

-   `find_potential_elements(doc)`: spaCyの`Doc`オブジェクトから、主語 (S)、動詞 (V)、目的語 (O)、補語 (C) などの主要な文要素を抽出します。
-   `determine_sentence_pattern(elements)`: `find_potential_elements`で抽出された要素と、それぞれの依存関係（`dep_`）や品詞（`pos_`）を基に、定義されたパターンに合致するかを判定し、文型を決定します。

### `find_potential_elements`の現在のロジック

-   **主語 (S):** `nsubj` (名詞主語), `nsubjpass` (受動態の名詞主語), `csubj` (補文主語) を探します。
-   **動詞 (V):** 文の`ROOT`トークンを動詞とします。
-   **直接目的語 (dobj):** 動詞の直接の子要素として`dobj`を探します。
-   **間接目的語 (iobj):** 動詞の直接の子要素として`iobj`を探します。
-   **補語 (C):**
    1.  `dobj`が存在する場合、その`dobj`の子要素から`oprd` (目的語の補語), `appos` (同格) を探して`complement`とします。
    2.  もし`complement`が見つからない場合、動詞（`root`）の直接の子要素から`acomp` (形容詞補語), `attr` (属性), `xcomp` (開いた補文節), `ccomp` (補文節) を探して`complement`とします。
-   **受動態:** 動詞の子要素に`auxpass`があるかで判定します。

### `determine_sentence_pattern`の現在のロジック（優先順位順）

1.  **受動態の文 - 形式主語 It 構文:** `voice`が受動態で、主語が"it"の場合。
2.  **受動態の文:** `voice`が受動態の場合。
3.  **SV (第1文型) - There is/are 構文:** 動詞の子要素に`expl` (虚辞) がある場合。
4.  **SVC (第2文型) - 形式主語 It 構文:** 主語が"it"で、動詞が"be"の語幹で、補語が存在する場合。
5.  **SVOC (第5文型):** 主語、動詞、直接目的語、補語が存在し、以下のいずれかの条件を満たす場合:
    -   補語の依存関係が`oprd`である。
    -   補語の依存関係が`appos`であり、動詞が`consider`, `call`, `name`, `elect`, `appoint`のいずれかである。
    -   補語の依存関係が`acomp`または`attr`であり、直接目的語が存在し、補語のheadが動詞である。
6.  **SVC (第2文型):** 主語、動詞、補語が存在し、補語の依存関係が`xcomp`でも`ccomp`でもない場合。
7.  **SVO (第3文型):** 主語、動詞が存在し、直接目的語、または句動詞の`particle`、または`xcomp`/`ccomp`の補語が存在する場合。
8.  **SV (第1文型):** 主語、動詞が存在する場合。

## 3. 現在のロジックの課題と理想的なロジック

### 3.1. `find_potential_elements`における課題と改善案

**課題:**
-   **`dobj`の識別不足:** 「She made me happy.」のようなSVOC文型において、`me`が`dobj`として正しく識別されないケースがある。これは、spaCyの依存関係解析が必ずしも動詞の直接の子要素として`dobj`を割り当てるとは限らないため。特に、動詞が目的語の補語を取る場合、目的語と補語の関係が複雑になる。
-   **補語の識別順序と依存関係の解釈:** `acomp`や`attr`がSVCとSVOCの両方で使われる可能性があるにも関わらず、現在のロジックでは`dobj`が見つからない場合に動詞の子要素として`acomp`/`attr`を探してしまうため、SVOCの補語がSVCの補語として誤って識別される可能性がある。

**理想的な改善案:**
-   **`dobj`のより堅牢な識別:** `dobj`が動詞の直接の子要素として見つからない場合でも、目的語の候補となる名詞句を探索するロジックを追加する。例えば、動詞の後に続く名詞句で、その名詞句が補語を伴う場合など。
-   **補語の識別ロジックの再構築:**
    1.  **目的語の補語 (SVOCのC) を最優先で識別:**
        -   `dobj`が存在する場合、その`dobj`の子要素から`oprd`, `appos`, `acomp`, `attr`を探して`complement`とする。
        -   特に、`acomp`や`attr`が目的語の補語として機能する場合、その`head`が目的語であるべきという条件を追加する。
    2.  **主語の補語 (SVCのC) を次に識別:**
        -   目的語の補語が見つからなかった場合にのみ、動詞（`root`）の子要素から`acomp`, `attr`, `xcomp`, `ccomp`を探して`complement`とする。この際、`acomp`や`attr`の`head`が動詞であること、かつ主語と意味的に関連することを確認する。
-   **`iobj`の識別強化:** SVOO文型を正確に判別するために、`iobj`の識別をより厳密にする。

### 3.2. `determine_sentence_pattern`における課題と改善案

**課題:**
-   **SVOCの判定条件の厳密化:** 現在のSVOC判定条件`c.head == v`は、`acomp`や`attr`が目的語の補語である場合に、その`head`が目的語であるべきという事実と矛盾する可能性がある。`c.head == v`だと、SVCの補語と混同するリスクがある。

**理想的な改善案:**
-   **SVOCの判定条件の修正:**
    -   `c.dep_ in ["acomp", "attr"]`の場合、`c.head == o1` (補語のheadが直接目的語である) という条件を追加する。これにより、`acomp`や`attr`が目的語の補語として機能していることを明確にする。
    -   修正後のSVOC条件例:
        ```python
        ("SVOC (第5文型)", lambda: s and v and o1 and c and (
            c.dep_ == 'oprd' or 
            (c.dep_ == 'appos' and v.lemma_ in ["consider", "call", "name", "elect", "appoint"]) or 
            (c.dep_ in ["acomp", "attr"] and o1 and c.head == o1) # ここを修正
        )),
        ```
-   **文型判別順序の再検討:**
    -   文型判別は、より複雑な文型から単純な文型へと順に判定していくのが一般的です。現在の順序は概ねそのようになっていますが、SVCとSVOの間の優先順位や、SVOOの追加を考慮する必要があります。
    -   **SVOO (第4文型) の追加:** `iobj`と`dobj`の両方が存在する場合にSVOOとして判定するロジックを追加する。これはSVOCの前に判定されるべきです。

## 4. まとめと今後の方向性

現在のロジックは基本的な文型判別には対応していますが、特にSVOC文型において、spaCyの依存関係解析結果の解釈に起因する課題が見られます。

今後の改善の方向性としては、`find_potential_elements`関数における目的語と補語の識別ロジックをより厳密にし、`determine_sentence_pattern`関数における各文型の判定条件を、依存関係の`head`情報などを活用してさらに精緻化することが挙げられます。特に、SVOC文型における`acomp`や`attr`の扱いを明確にすることで、判別精度を向上させることが期待されます。

また、SVOO文型の追加も重要な改善点となります。
