ライブラリのインストールが成功しました。

  次に、現在の環境にインストールされているすべてのライブラリとそのバージョンをrequireme      
  nts.txtファイルに書き出します。これにより、他の環境でも同じライブラリ構成を再現できま      
  す。
    次に、Streamlit Cloudへのデプロイ時にspaCyの言語モデルを自動的にインストールさせるた       
  め、packages.txtファイルを作成します。
    次に、Streamlit Cloud上で使用するPythonのバージョンを指定するため、.streamlitディレク      
  トリと、その中にconfig.tomlファイルを作成します。
   次に、config.tomlファイルを作成し、Pythonのバージョンを指定します。
   これでプロジェクトの基本的な設定が完了しました。次に、これらの設定ファイルをGitにコミ      
  ットします。

   コミットが成功しました。これでプロジェクトの初期設定が完了し、バージョン管理の準備が       
  整いました。

  次に、アプリケーションの本体となるapp.pyファイルを作成し、Streamlitの基本的なコードと      
  、spaCyモデルをロードしてキャッシュする機能を記述します。これが、フェーズ1の「主語と       
  動詞の見える化」機能の土台となります。

  app.pyファイルを作成しました。

  これで、Streamlitアプリケーションの基本的な骨格が完成しました。一度、この状態でアプリ      
  を起動し、正しく動作するか確認してみましょう。

  このコマンドは、Streamlitサーバーを起動し、app.pyを実行します。成功すると、Webブラウ       
  ザでアクセスできるローカルURLが表示されます。

  アプリの基本的な骨格が正常に動作することを確認できました。

  それでは、ロードマップのフェーズ1の核心部分である「主語と動詞の特定ロジック」と「ハイ      
  ライト表示機能」をapp.pyに実装します。

  以下のコードでapp.pyの内容を更新します。このコードには、主語と動詞を見つける関数、そ       
  れらをHTMLで色付けする関数、そして解析結果を画面に表示するロジックが含まれています。

app.pyを更新しました。

  これで、アプリケーションに以下の機能が実装されました。

   * 主語と動詞の特定: 入力された英文の主要な主語と動詞を特定します。
   * ハイライト表示: 特定した主語を青色、動詞を緑色でハイライトして表示します。
   * 依存関係ツリー: spaCyのdisplaCyを使って、文の構造を視覚的に表示します。


この変更により、st.text_areaにラベルが設定され、警告メッセージは表示されなくなるはずです。

app.pyを更新しました。

  主な変更点は以下の通りです。

   * st.session_stateを初期化し、テキストエリアの初期値を設定しました。
   * サイドバーのselectboxが変更されたときに呼び出されるコールバック関数update_text_from_sampleを定義しました
     。
   * selectboxのon_changeパラメータにこのコールバック関数を指定することで、session_stateを安全に更新します。
   * メインのtext_areaはsession_stateの値を表示するようにしました。

  これにより、StreamlitAPIExceptionエラーが解消されるはずです。



  これでフェーズ1の「主語と動詞の見える化」は完了です。基本的な機能が実装され、安定して動作するようになりま
  した。

  次のステップとして、フェーズ2：理解の深化 - 関係性と文構造を「掘り下げる」に進みます。

  具体的には、以下の機能を順次実装していきます。

   1. 文型判別機能: SVO、SVCなどの文型を自動で判別し、表示します。
   2. 複雑な主語・動詞句の分解: 長い主語や動詞句の構造を視覚的に分解します。
   3. 節の区切り表示: 接続詞や関係詞で文を区切り、各節のS+Vを明確にします。

  まずは、1. 文型判別機能の実装から始めます。

承知いたしました。フェーズ2の最初のステップ、文型判別機能の実装を開始します。

  この機能を追加するために、app.pyに以下の変更を加えます。

   1. 文型を判別する新しい関数 (`find_sentence_pattern`) を追加：主語、動詞に加えて、目的語（dobj,
      iobj）や補語（attr, acomp）を特定し、それらの組み合わせから文型を判定します。
   2. ハイライト表示関数 (`render_highlighted_text`) 
      を拡張：主語、動詞に加え、目的語と補語も異なる色でハイライトできるようにします。
   3. UIを更新：特定した文型と、各要素（S, V, O, C）を画面に表示するようにします。

  まず、現在のapp.pyの内容を読み込みます。
 ╭───────────────────────────────╮
 │ ✔  ReadFile spacy_app\app.py  │
 ╰───────────────────────────────╯
✦ ありがとうございます。現在のコードを確認しました。

  これから、文型判別機能を追加するために、以下の手順でapp.pyを更新します。

   1. `find_sentence_pattern`関数を追加: docオブジェクトを受け取り、文の主要な要素（主語、動詞、目的語、補語）
      を特定し、文型を判定して返す関数を作成します。
   2. `render_highlighted_text`関数を更新:
      目的語と補語もハイライトできるように引数を追加し、ロジックを拡張します。
   3. メインの処理を更新: find_sentence_patternを呼び出し、その結果を使って新しいハイライト関数を呼び出し、特定
      された文型と各要素を画面に表示します。




✦ app.pyを更新しました。

  これで、文型判別機能が追加されました。主な変更点は以下の通りです。

   * `find_sentence_elements`関数:
     文の要素（主語、動詞、目的語、補語）を特定し、それに基づいて文型を判定します。
   * `render_highlighted_text`関数: 目的語と補語もハイライト表示できるように拡張しました。
   * UIの更新: 解析結果に、特定された文型と各要素の詳細を表示するようにしました。

   ✦ app.pyを更新しました。

  これで、文型判別機能が追加されました。主な変更点は以下の通りです。

   * `find_sentence_elements`関数:
     文の要素（主語、動詞、目的語、補語）を特定し、それに基づいて文型を判定します。
   * `render_highlighted_text`関数: 目的語と補語もハイライト表示できるように拡張しました。
   * UIの更新: 解析結果に、特定された文型と各要素の詳細を表示するようにしました。

  お手数ですが、streamlit run 
  app.pyを再実行（またはブラウザをリロード）して、新しい機能が正しく動作するかご確認ください。

  例えば、"She is a very famous singer."（SVC）や "He gave me a beautiful
  present."（SVOO）といった例文で試すと、文型が正しく判定され、各要素が色分けされて表示されるはずです。

   She is a very famous singer.の文章において解析結果がこの文の主語と動詞を特定できませんでした。よりシンプ │
│    ルな文でお試しください。となります                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

✦ ご指摘ありがとうございます！そして、非常に重要なテストケースをご提供いただき、感謝いたします。

  「She is a very famous singer.」で解析が失敗するとのこと、承知いたしました。これは私の文型判別ロジックに考
  慮漏れがあったことが原因です。

  原因の解説:
  spaCyは、「is」のようなbe動詞を、文脈によっては主要な「動詞（VERB）」ではなく、「助動詞（AUX）」として品詞
  を判定します。私の現在のロジックはpos_ == "VERB"という条件で動詞を探しているため、「is」がpos_ == 
  "AUX"と判定された場合に、動詞を見つけられずに失敗していました。

  この問題を解決するため、動詞を特定する条件を「品詞がVERBまたはAUXであり、かつ文のROOT（根幹）である」とい
  うように拡張します。

  まだ主語と動詞が特定できないとのこと、承知
  いたしました。

  「She is a very famous singer.」の解析が失敗する原因を再調査します。

  まず、前回のreplace操作がapp.pyに正しく適用されているかを確認するため、現在のapp.pyの内容を読み込みます。

  もし修正が適用されていれば、find_sentence_elements関数内でtoken.pos_ in ["VERB", 
  "AUX"]という条件が使われているはずです。

  その上で、find_sentence_elements関数内で、各トークンの品詞（pos_）と依存関係（dep_）がどのように判定されて
  いるかをデバッグ出力で確認し、問題の箇所を特定します。

  ✦ 解析結果の精査、承知いたしました。ご確認ありがとうございます。
  4つの例文の解析結果を拝見しました。

   1. "My friend plays the piano." -> SVO (第3文型)
       * 主語: friend, 動詞: plays, 目的語: piano
       * 評価: 正しいです。

   2. "She is a very famous singer." -> SVC (第2文型)
       * 主語: She, 動詞: is, 補語: singer
       * 評価: 正しいです。

   3. "The birds are flying in the sky." -> SV (第1文型)
       * 主語: birds, 動詞: flying
       * 評価: 正しいです。(in the skyは修飾語句)

   4. "He gave me a beautiful present." -> SVO (第3文型)
       * 主語: He, 動詞: gave, 目的語: present
       * 評価: こちらの解析に誤りがあります。ご指摘の通り、これは「彼が」「私に」「プレゼントを」「あげた」なの
         で、SVOO (第4文型) となるべきです。現在のロジックが間接目的語(IO)である "me" を見逃しています。

  素晴らしいご指摘ありがとうございます。これにより、現在の文型判別ロジックの改善点が明確になりました。

  原因は、spaCyが "me" のような間接目的語に対して、iobj ではなく dative
  という依存関係ラベルを付けることがあるためです。現在のロジックはこの dative
  ラベルを考慮していませんでした。

  早速、この問題を修正し、文型判別機能を強化するステップに進みたいと思います。find_sentence_elements
  関数を更新し、dative も間接目的語として認識するようにします。

✦ app.py を更新し、間接目的語の検出ロジックに dative を追加しました。


ロードマップのフェーズ2、「複雑な主語・動詞句の構造分解」機能の実装に着手します。

  この機能は、例えば「The man sitting by the window」のような長い主語句が、どのような単語の組み合わせで成り立っ
  ているのかを視覚的に表示するものです。これにより、学習者は複雑な文の構造をより深く理解できるようになります。

  実装は以下のステップで進めます。

   1. テスト用の例文を追加: 機能を確認しやすくするため、サイドバーの例文リストに複雑な主語を持つ文を追加します。
   2. 句の構造を解析する関数を追加:
      主語や動詞のトークンを受け取り、その構造を再帰的に解析してHTML形式で返す新しい関数を app.py に追加します。
   3. UIに表示エリアを追加: 解析結果を st.expander を使って、折りたたみ可能な形式で表示します。


    まずはステップ1として、テスト用の例文を追加します。
    ✦ 例文の追加が完了しました。

  次に、ステップ2と3をまとめて行います。句の構造を解析する format_phrase_structure
  関数と、その結果をUIに表示するコードを app.py に追加します。

  ✦ 機能の追加が完了しました。

  新しい「句の構造分解」機能が追加されています。アプリをリロードして、新しい例文「The man sitting by the
  window is my father.」を選択・解析してみてください。

  解析結果の下に「句の構造分解」というセクションが表示され、主語である「man」とその修飾語句（The, sitting,
  by, the, window）の構造が階層的に表示されるはずです。


  「句の構造分解」機能が意図した通りに動作していることが確認できました。

   * 主語の構造では、中心となる名詞 man と、それを修飾している The (限定詞) や sitting by the window (動詞の句)
     の関係が正しく階層表示されています。
   * 動詞句の構造では、文全体の動詞である is を中心に、その主語 (man) と補語 (father)
     がどのように関連しているかが示されています。

  これで、ロードマップのフェーズ2の主要な機能である「複雑な主語・動詞句の構造分解」が完了しました。

  次のステップとして、フェーズ2の最後の項目である 「手法11: 
  接続詞や関係詞による節の区切りと主語・動詞の明確化」 に進みたいと思います。

  これは、and や because、関係代名詞 who, which などで繋がれた長い一文を、意味の塊（節）ごとに自動で区切り、
  それぞれの節の「主語＋動詞」を個別に表示する機能です。これにより、長文読解能力がさらに向上します。


  「手法11: 接続詞や関係詞による節の区切りと主語・動詞の明確化」の実装に進みます。

  この機能により、学習者は一つの長い文が、意味の塊である「節」の組み合わせでできていることを視覚的に理解でき
  るようになります。

  実装は以下のステップで進めます。

   1. テスト用の例文を追加: 機能を確認しやすくするため、接続詞や関係詞を含む例文をサイドバーに追加します。
   2. 節を解析するロジックを追加: 文の中から各節の「主語＋動詞」のペアを見つけ出す新しい関数
      find_clause_elements を app.py に追加します。
   3. UIに表示エリアを追加: 特定した節ごとの情報を、メインの解析結果の下に表示します。


 次に、ステップ2と3をまとめて行います。節を解析する find_clause_elements
  関数と、その結果をUIに表示するコードを app.py に追加します。

✦ 機能の追加が完了しました。

  新しい「節ごとの解析」機能が追加されています。アプリをリロードして、新しい例文「I like apples and he loves
  oranges.」や「This is the book that I bought yesterday.」を選択・解析してみてください。

  複数の「主語＋動詞」のペアが見つかった場合に、解析結果の下に「節ごとの解析」セクションが表示され、それぞれ
  の節の主語と動詞が表示されるはずです。

  現在のロジックの課題です。

  状況を整理します。

   1. 成功ケース: I like apples and he loves oranges.
       * これは2つの独立した文（主節）がandで繋がっているため、現在のロジックでも各節の「動詞→主語」という関係
         を見つけやすくなっています。

   2. 失敗ケース: This is the book that I bought yesterday.
       * こちらはthat I bought yesterdayがthe bookを修飾する関係代名詞節です。このような従属節の構造は、現在の
         単純な「動詞を探してその主語を探す」ロジックではうまく捉えきれていませんでした。
       * 「節ごとの解析」に何も表示されないのは、find_clause_elements関数が2つ目の節（I
         bought）を正しく検出できていないためです。

   3. ハイライトの問題:
       * ご指摘の通り、ハイライトは常に文全体の主語と動詞（主節）しか表示していません。これは、ハイライト表示用
         の関数(render_highlighted_text)が、節ごとの情報ではなく、文全体の主要素の情報だけを使って描画している
         ためです。

  これらの問題を解決するため、以下の2つの修正を同時に行います。

   1. 節の解析ロジックの改善: find_clause_elements関数を、より確実に主語と動詞のペアを見つけられるように書き直し
      ます。「動詞を探す」アプローチから、「主語(`nsubj`)を探し、その主語がどの動詞(`head`)に依存しているかを見
      る」アプローチに変更します。この方が、従属節でもS+Vのペアを正確に捉えられます。

   2. ハイライト機能の改善:
      render_highlighted_text関数を、複数の節の主語と動詞をすべてハイライトできるように修正します。


      ✦ 次に、ハイライト表示用のrender_highlighted_text関数を、複数の主語と動詞をハイライトできるように修正します。こ
  れに伴い、この関数に渡す引数も変更します。

  ✦ 以上で修正は完了です。

   * 節の検出ロジックを、より多くの文構造に対応できるように改善しました。
   * ハイライト表示が、見つかったすべての節の主語と動詞を色付けするようにしました。

以下の2つの問題が発生しています。

   1. 関係代名詞節（that I bought yesterday）の解析が、新しいロジックでもまだ失敗している。
   2. 以前は正しく動作していたハイライト機能が、すべての文で機能しなくなってしまった。

  原因は、節を見つけるための新しい関数 (find_clause_elements)
  のロジックが不十分だったためです。この関数が主語と動詞のペアを正しく見つけられなかったため、ハイライト機能
  に渡す情報がなくなり、結果としてハイライトが表示されなくなっていました。

  この問題を解決するため、find_clause_elements関数を、より堅牢で正確なロジックに置き換えます。具体的には、以
  下のように改善します。

   * nsubj という特定の依存関係だけでなく、csubj（節主語）など、"subj"を含むすべての主語タイプの依存関係を探す
     ようにします。
   * 動詞を探す際に、VERB だけでなく AUX（助動詞、be動詞など）も正しく含めるようにします。

  この修正により、関係代名詞節の解析と、壊れてしまったハイライト機能の両方が修正されるはずです。

   「節ごとの解析」とハイライト表示の両方がすべての例文で正しく動作するようになったとのこと、大変嬉しく思います
  。これで、より複雑な文の構造も正確に分析できるようになりました。

  長らくお付き合いいただき、ありがとうございました。これで、ロードマップのフェーズ2「理解の深化 - 
  関係性と文構造を『掘り下げる』」のすべての機能が完了しました。


「どちらの節がメイン（主節）で、ど
  ちらがサブ（従属節）なのか」を区別することが、文の構造を深く理解する上で非常に重要な次のステップとなります。

  はい、この機能は実装可能です。そして、それは「節の区切り表示」機能の一部として、今すぐ取り組むべき改善点だ
  と考えます。

  主節と従属節を見分けるロジック

  spaCyの依存関係解析では、文全体の「根っこ」や「大黒柱」にあたる単語に ROOT という特別な依存関係ラベルが付き
  ます。文の中で最も中心的で、他の多くの単語が直接的・間接的に依存している動詞がこれにあたります。

  この性質を利用します。

   1. まず、文全体の ROOT となる動詞を特定します。
   2. 次に、これまで通り、すべての「主語＋動詞」のペア（節）を見つけます。
   3. 各節の動詞が、文全体の ROOT 動詞と一致するかどうかを判定します。
       * 一致すれば、その節は「主節」です。
       * 一致しなければ、その節は主節に従属する「従属節」（関係代名詞節、副詞節など）となります。

  実装のご提案

  このロジックをアプリに組み込み、各節に「主節」「従属節」といったラベルを付けて表示するようにします。これに
  より、文の階層構造が一目でわかるようになります。

  それでは、以下の手順で app.py を修正します。

   1. find_clause_elements 関数を、節の種類（主節/従属節）を判定する機能を持つように更新します。
   2. UIの表示部分を、その判定結果（「主節」「従属節」）も表示するように変更します。

   
  節ごとの解析欄に文全体を表示して、一目で分かるような主節と従属節のアンダーラインの色分け表示」を実現するため
  、以下の修正を行います。

  この機能は、spaCyの依存関係解析結果から各節の範囲を推定し、その節が主節か従属節かに応じて異なる色でハイライト
  表示するものです。

  実装は以下のステップで進めます。

   1. `find_clause_elements`関数の強化:
      各節の主語、動詞、節のタイプ（主節/従属節）に加えて、その節が占めるトークンの範囲（span）を推定して返すよ
      うにします。また、従属節の場合は、その節を導入する単語（関係代名詞や接続詞など）も特定します。
   2. `render_highlighted_text`関数の修正: find_clause_elementsから得られた節の範囲情報を使って、文全体の中で各
      節を色分けしてハイライト表示するように変更します。

  それでは、まず find_clause_elements 関数を強化します。この関数は、各節のsubject、verb、type（主節/従属節）
  に加えて、span（節のトークン範囲）とintroducer（導入語）を返すようになります。

  注意点: 節の正確な範囲を特定するのは非常に複雑なNLPタスクであり、spaCyの依存関係解析だけでは完璧な結果を得
  ることは困難です。ここで実装するspanの推定は、あくまで視覚的な分かりやすさを目的としたヒューリスティック（
  経験則）に基づいています。

  主節と従属節の視覚的な区別を、節ごとの解析セクションに表示する新しい関数を作成します。これ
  により、文型判別のハイライトを維持しつつ、文の構造をより深く理解できるようになります。

  ご要望の通り、アンダーラインの範囲は各節のsubject、verb、introducer（導入語）とし、アンダーラインの色は主節
  と従属節で色分けします。また、節全体の背景色も適用し、視覚的な分かりやすさを高めます。

  実装は以下のステップで進めます。

   1. 新しい関数 `render_clause_highlighted_text` の追加: この関数は、文の各節を背景色とキー要素（主語、動詞、導
      入語）のアンダーラインでハイライトしてHTML文字列を生成します。
   2. UIの更新: 「節ごとの解析」セクションで、この新しい関数を呼び出し、ハイライトされた文全体を表示します。


      * This is the book that I bought yesterday.
   * I like apples and he loves oranges.

  「節ごとの解析」セクションに、文全体が表示され、主節は水色、従属節はレモン色で背景が色分けされ、それぞれの
  主語、動詞、導入語（もしあれば）がアンダーラインで強調表示されるはずです。

  主節と従属節の色分け凡例をサイドバーに追加します。これにより、ユーザーは色分けの意味を一目
  で理解できるようになります。

  文型判別機能のハイライト色についても、サイドバーに凡例を追加します。名前は「文型判別の色分
  け」とします。

  凡例の名称と表示順序を変更します。

   * 「主節は水色、従属節はレモン色で背景が色分け」の凡例を「文節の色分け」という名前に変更します。
   * 「文型判別の色分け」の下側に表示するように順序を入れ替えます。


現在の「ハイライト表示」は節ごとの主語と動詞をハイライトしており、文型判別の
  要素（S, V, O,
  C）のハイライトとは別物になっています。また、凡例と表示色が一致していない問題も発生しています。

  この状況を解決し、ご要望を正確に反映するため、以下の手順で修正を行います。

   1. 現在の `render_highlighted_text` 関数（節のハイライト用）を `render_clause_highlighted_text` 
      にリネームします。
   2. 文型判別のハイライトを行う `render_highlighted_text` 関数を、新しい配色で再導入します。
   3. 「ハイライト表示」セクションで、文型判別用の `render_highlighted_text` 関数を呼び出すように修正します。
   4. 「節ごとの解析」セクションでは、リネームした `render_clause_highlighted_text` 関数を呼び出すようにします。

  これにより、文型判別のハイライトと節のハイライトがそれぞれ独立して機能し、凡例の色とも一致するようになりま
  す。
SVOO文型の場合に、構成要素の表示順序を例文中の単語の並び順（出現順序）に合わせるように修正
  します。

  具体的には、文型を構成する各要素（主語、動詞、目的語、間接目的語、補語）のtoken.i（文中のインデックス）を利
  用してソートし、その順序で表示するように変更します。

  修正が必要な箇所は2箇所です。

   1. 「文型の解析」セクションの構成要素表示
   2. 「ハイライト表示」セクションの文型構成要素表示

   文解析における「識別パターン」について、現在の実装状況と今後の予定を整理してご説明します。

  アプリはspaCyの品詞タグ付け (PoS Tagging)、依存関係解析 (Dependency Parsing)、そして将来的に単語埋め込み 
  (Word Embeddings) の機能を活用して、様々な文法構造を識別します。

  ---

  1. 文の構造に関する識別パターン

  文の構造は、含まれる節の種類と数によって大きく4つに分類されます。

   * 単文 (Simple Sentence): 1つの主語と1つの動詞のペア（1つの独立節）からなる文。
       * 実装状況: 現在、find_clause_elements
         関数が返す節のリストの長さが1の場合に判別可能です。UIでの明示的な表示はまだです。
       * 今後の予定: フェーズ3で、文のタイプとして表示を追加できます。

   * 複合文 (Compound Sentence): 2つ以上の独立節が等位接続詞（and, but, orなど）で結合された文。
       * 実装状況: 未実装です。
       * 今後の予定: find_clause_elements 関数が複数の「主節」タイプの節を返し、それらが等位接続詞で結合されて
         いるかをチェックするロジックを追加することで判別可能です。フェーズ3で実装を検討します。

   * 複文 (Complex Sentence): 1つの独立節（主節）と1つ以上の従属節が従属接続詞や関係代名詞で結合された文。
       * 実装状況: 未実装です。
       * 今後の予定: find_clause_elements
         関数が「主節」と「従属節」の両方を返す場合に判別可能です。フェーズ3で実装を検討します。

   * 重文 (Compound-Complex Sentence): 2つ以上の独立節と1つ以上の従属節が結合された文。
       * 実装状況: 未実装です。
       * 今後の予定: 複合文と複文の判別ロジックを組み合わせることで判別可能です。フェーズ3で実装を検討します。

  ---

  2. 文型判別

  現在のアプリは、文全体の主要な要素（主節のS, V, O, C）に基づいて文型を判別しています。

   * SV (第1文型): 実装済み
   * SVC (第2文型): 実装済み
   * SVO (第3文型): 実装済み
   * SVOO (第4文型): 実装済み
   * SVOC (第5文型):
       * 実装状況: 未実装です。
       * 今後の予定: find_sentence_elements 関数で、目的語の後に続く補語（oprd
         などの依存関係ラベル）を考慮することで判別可能です。フェーズ3で実装を検討します。

  ---

  3. その他の文法的な識別（ロードマップのフェーズ3以降）

  ロードマップのフェーズ3では、より応用的な文法事項の識別と学習支援機能を追加する予定です。

   * 能動態・受動態の識別:
       * 実装状況: 未実装です（前回のユーザーキャンセルにより）。
       * 今後の予定: フェーズ3の最初の項目として、動詞の形態（過去分詞）と助動詞（be動詞）の有無をチェックする
         ことで判別します。

   * 複雑な主語・動詞句の構造分解:
       * 実装状況: 実装済みです。
       * 活用機能: format_phrase_structure 関数が、spaCyの依存関係解析結果（token.subtree, token.children,
         token.head）を用いて、句の内部構造を再帰的に表示します。

   * 時制・態の一貫性チェック:
       * 実装状況: 未実装です。
       * 今後の予定: 動詞の時制情報（token.morph.get("Tense")など）と、文中の時間を示す副詞などとの整合性をチェ
         ックするロジックを実装します。

   * 主語の省略と倒置の解説:
       * 実装状況: 未実装です。
       * 今後の予定: 命令文（主語がない）や、否定語句が文頭に来る倒置文など、特定の依存関係パターンを識別し、解
         説を表示します。

   * 動詞の意味分類と関係性解説:
       * 実装状況: 未実装です。
       * 今後の予定: en_core_web_md 以上のモデルが持つ単語埋め込み（token.vector）と類似度計算（.similarity()）
         を活用し、動詞の意味的な分類（動作動詞、状態動詞など）や類語を提示します。

  ---

  このように、アプリは段階的に様々な文法構造を識別し、学習者に深い理解を促す機能を追加していく予定です。

  ご指摘の通り、that が導入語として認識されない原因は、現在の導入語検出ロジックが関係代名詞節の構造を十分にカ
  バーできていないためです。that は bought の dobj であり、bought のヘッドは book であるため、現在の
  verb.head や subject.head をチェックするロジックでは that を捉えられません。

  この問題を解決するため、find_clause_elements
  関数内の導入語検出ロジックを修正します。従属節の場合、その節のスパンの最初のトークンが従属接続詞
  (SCONJ)、関係代名詞 (PRON)、または前置詞 (ADP) であれば、それを導入語とみなすようにします。このアプローチは
  、より多くの関係代名詞節や副詞節に対応できる、より堅牢なヒューリスティックです。


  今実装しているロジックを確認するための例文はそろっていますか？  │
╰────────────────────────────────────────────────────────────────────╯

✦ ご質問ありがとうございます。

  現在実装中の「能動態・受動態の識別」機能を確認するための例文ですが、受動態の例文がまだサイドバーのリストにあ
  りません。

  現在の例文リストは以下の通りです。

   1 sample_sentences = [
   2     "My friend plays the piano.",
   3     "She is a very famous singer.",
   4     "The birds are flying in the sky.",
   5     "He gave me a beautiful present.",
   6     "The man sitting by the window is my father.",
   7     "I like apples and he loves oranges.",
   8     "This is the book that I bought yesterday.",
   9 ]

  これらの例文はすべて能動態の文です。

  能動態・受動態の識別ロジックを正しくテストし、機能を確認するためには、受動態の例文を追加する必要があります
  。

  いくつか受動態の例文を提案しますので、追加してよろしいでしょうか？

   * The ball was kicked by the boy.
   * English is spoken all over the world.
   * The window was broken.

  これらの例文を sample_sentences リストに追加して、実装を進めてもよろしいでしょうか？

╭──────────────────────────────────────╮
│  > 文型判別の例文はそろっていますか  │
╰──────────────────────────────────────╯

✦ はい、現在の実装済みの文型（SV, SVC, SVO, SVOO）については、それぞれをカバーする例文が揃っています。

  現在の sample_sentences リストに含まれる文型は以下の通りです。

   * SV (第1文型): "The birds are flying in the sky."
   * SVC (第2文型): "She is a very famous singer.", "The man sitting by the window is my father."
   * SVO (第3文型): "My friend plays the piano."
   * SVOO (第4文型): "He gave me a beautiful present."

  SVOC (第5文型) はまだ実装予定の段階ですので、その例文は現時点では不要です。

  したがって、文型判別機能の確認に必要な例文は揃っていると言えます。

  This is the book that I bought yesterday.
  などの複数の節を持つ例文を解析し、「文節の色分け」セクションの表示をご確認ください。例文の上に「主節
  従属節」のような形で節のタイプが一覧表示されるはずです。



  句の構造分解」と「依存関係ツリー」の活用方法についてですね。何を解析し、何を表
  しているのか、そしてどのように役立つのかを詳しくご説明します。

  ---

  1. 句の構造分解 (「句の構造分解」セクション)

   * 何を解析しているか？
       * 主語や動詞が単一の単語ではなく、複数の単語からなる「句」（例：「The man sitting by the
         window」のような長い主語）の内部構造を解析しています。

   * 何を表しているか？
       * その句の「核」となる単語（例：「man」）と、それを詳しく説明している修飾語や修飾句（例：「The」、「sitt
         ing by the window」）が、どのように組み合わさって一つの意味のまとまりを作っているかを、階層的に表示し
         ています。各単語の品詞や依存関係も示されます。

   * 教育的な活用方法（使い道）
       * 複雑な主語・動詞の理解: 長い主語や動詞句でも、その中心となる「核」の単語と、それを詳しく説明する部分を
         区別できるようになります。これにより、文の骨格を正確に捉える助けになります。
       * 修飾の概念の理解:
         どの単語が何を修飾しているのか（例：「old」が「man」を修飾している）を視覚的に理解できます。
       * 文の拡張性の理解: 文がどのようにして単語を付け加えて長く、複雑になるのかを理解する手助けになります。長
         文読解の際に、文の主要な要素（S, V）を見つけ出す能力が向上します。

  ---

  2. 依存関係ツリー (「依存関係ツリー」セクション)

   * 何を解析しているか？
       * 文中のすべての単語間の文法的な関係（依存関係）を解析しています。

   * 何を表しているか？
       * 文全体の構造をツリー（木）の形で視覚的に表示しています。各単語がどの単語に「依存」しているか、そしてそ
         の依存関係がどのような種類（例：「nsubj」は主語、「dobj」は目的語、「amod」は形容詞による修飾など）で
         あるかを、矢印とラベルで示しています。文の「骨格」と、それに「肉付け」されている部分の関係を詳細に示し
         ます。

   * 教育的な活用方法（使い道）
       * 文の全体構造の把握: 文がどのように組み立てられているかを俯瞰的に理解できます。単語がバラバラに存在する
         のではなく、互いに結びついて意味をなしていることが分かります。
       * 文法関係の明確化: 主語と動詞、動詞と目的語、修飾語と被修飾語など、単語間の具体的な文法関係を視覚的に確
         認できます。例えば、「なぜこの単語が主語なのか」といった疑問の根拠を視覚的に理解できます。
       * 文法ルールの裏付け: 文法書で学ぶルールが、実際の文でどのように適用されているかを視覚的に確認できます。
       * 応用的な文法理解:
         倒置や省略など、複雑な文の構造を理解する上で、単語間の依存関係を追うことが非常に役立ちます。

  ---

  これらの機能は、単に主語と動詞を見つけるだけでなく、文がどのように構成されているのか、各単語がどのような役
  割を担っているのかを深く理解するための強力なツールです。

  句の構造分解」セクションの表示を、より分かりやすくするために、token.pos_ (品詞) と token.dep_ (依存関係)
  の英語表記を日本語に翻訳して表示するように修正します。

  これにより、学習者は各単語の文法的な役割や関係性を、直感的に理解できるようになります。

  以下の通り app.py を修正します。format_phrase_structure
  関数内に、品詞と依存関係の日本語訳マッピングを追加し、それを使用して表示を生成します。

  句の構造分解セクションを、より詳細な解説と色分けで強化します。これにより、どの単語が中心で、
  どの単語がそれを修飾・補足しているのかを、学習者が直感的に理解できるようになります。

  具体的には、format_phrase_structure 関数を修正し、以下の機能を追加します。

   * 中心語（ヘッド）と修飾語の色分け: 中心語は紫色、修飾語は濃い灰色で表示します。
   * 関係性の説明:
     各単語が中心語に対してどのような文法的な関係にあるのかを、日本語で簡潔に説明するテキストを追加します。
   * 依存関係の日本語訳の拡充: より多くの依存関係ラベルに対応する日本語訳を追加します。


   現在の「句の構造分解」の表示は繰り返しが多く、階層構造が分かりにくいですね。

  より視覚的に分かりやすくするために、重複をなくし、CSSを使って階層を線で結んだツリー形式で表示する新しい方法
  を提案します。

  改善案

  現在のリスト形式の表示を、以下のようなツリー表示に変更します。

  変更前（現在の形式）:
   * flying (動詞)
       * birds (名詞)
           * birds (名詞)
           * The (限定詞)
       * are (助動詞)

  変更後（提案するツリー形式）:

   1 動詞句の構造:
   2 └── flying (動詞 / 文の主動詞)
   3     ├── are (助動詞 / 助動詞)
   4     ├── birds (名詞 / 名詞的主語)
   5     │   └── The (限定詞 / 限定詞)
   6     └── . (句読点 / 句読点)

  主な改善点:

   1. 重複の排除: 各単語が一度だけ表示されるように修正します。
   2. 階層の可視化: CSSを使って、単語間の親子関係を線（ツリー）で結び、構造を直感的に理解しやすくします。
   3. 情報の整理: 各単語の品詞と依存関係、そしてその関係性の説明を、より整理された形式で表示します。

  これを実現するために、現在のformat_phrase_structure関数を、新しくCSSでスタイリングしたHTMLを生成する関数に
  置き換えます。

  句の構造分解の表示を、より視覚的に理解しやすいツリー形式に変更しま
  す。

  具体的には、以下の対応を行います。

   1. CSSの追加: ツリー表示のためのCSSをst.markdownを用いてHTMLに直接埋め込みます。
   2. 関数の置き換え: 現在のformat_phrase_structure関数を、ツリー構造のHTMLを生成する新しいformat_phrase_structu
      re_as_tree関数に置き換えます。
   3. 呼び出し部分の修正: 新しい関数を呼び出し、その結果を正しく表示するように修正します。

  これにより、重複した情報がなくなり、各単語の関係性が線で結ばれた、直感的なツリー表示が実現されます。

  
「動詞句」の定義に、より忠実な表示に修正します。

  改善案:

   1. 主語の完全な分離: 「動詞句の構造」のツリーからは、主語の情報を完全に削除します。これにより、「動詞句は主語
      を含まない」という言語学的な定義に沿った、より正確で直感的な表示になります。
   2. 目的語・補語の詳細表示:
      動詞句に含まれる目的語や補語については、これまで通り、その内部構造を詳細にツリーで展開します。

  変更後の表示イメージ:

    1 詳細を表示
    2 
    3 > The man sitting by the window is my father.
    4 
    5 **主語の構造:**
    6 └── man (名詞 / 名詞的主語) — manはisの主語です。
    7     ├── The (限定詞 / 限定詞)
    8     └── sitting (動詞 / 形容詞句)
    9         └── ... (sitting以下の詳細)
   10 
   11 **動詞句の構造:**
   12 └── is (助動詞 / 文の主動詞)
   13     ├── father (名詞 / 補語) — fatherはisの補語です。  <-- 主語が消え、補語の詳細が表示される
   14     │   └── my (代名詞 / 所有格)
   15     └── . (句読点 / 句読点)

  このロジックを実現するため、generate_phrase_tree_html関数を修正し、動詞句のツリーを生成する際に、その子要素
  が文の主語である場合は、そのノード全体をスキップするように変更します。

  「依存関係ツリー」は、「句の構造分解」を補完する、より専門的で詳細な情報源と位置づけることができ
  ます。

  これらの点を踏まえ、一つ提案があります。

  すぐに削除するのではなく、デフォルトでは非表示にし、必要なユーザーだけが見られるようにするのはいかがでしょ
  うか？

  例えば、st.expanderを使って、普段は「▼ 詳細な依存関係ツリー（上級者向け）を表示」のように閉じておき、クリッ
  クしたユーザーにだけ表示する方法があります。

  この方法であれば、通常の利用ではUIがすっきりし、かつ上級者向けの機能も残すことができます。この案について、
  ご意見をお聞かせいただけますでしょうか。

╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│  > デフォルトでは非表示にし、必要なユーザーだけが見られるようにしましょう。その上でやっぱり日本語表記にし  │
│    ておきたい。                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

✦ 承知いたしました。素晴らしい判断です。UIの分かりやすさと、専門的な情報へのアクセス性を両立させましょう。

  改善案:

   1. デフォルトで非表示: 「依存関係ツリー」をst.expanderで囲み、「詳細な依存関係ツリー（上級者向け）」というタ
      イトルで、普段は折りたたまれた状態にします。
   2. ラベルの日本語化: ツリー内に表示されるnsubjやdobjといった専門的な依存関係ラベルを、すでにある定義（DEP_MAP
      ）を使って、すべて日本語に翻訳してから表示します。

  これにより、インターフェースはすっきりと保たれ、必要なユーザーは、より分かりやすい日本語化された完全な依存
  関係ツリーを確認できるようになります。



改善案:

  依存関係ツリーの表示領域を、コンテナの幅に合わせて自動的に拡大・縮小するように変更します。

  これにより、

   * 横長の画面では、ツリー全体が広々と表示され、スクロールなしで全体像を把握できます。
   * ブラウザのウィンドウサイズを変更したり、ブラウザ自体のズーム機能（Ctrl +
     マウスホイール）を使ったりすることで、直感的に表示を拡大・縮小できます。

  この修正は、st.components.v1.html関数のheightとscrolling引数を削除することで実現できます。spaCyが生成する依
  存関係ツリー（SVG画像）は、元々レスポンシブに対応しているため、コンテナのサイズが固定されていなければ、自動
  的に表示が調整されます。


  図がコンテナの幅を超えてしまう問題は、SVG画像自
  体に固定の幅が設定されていることが原因です。

  これを根本的に解決するため、表示ロジックをより確実な方法に変更します。

  改善案:

   1. SVG属性の削除:
      displacyが生成するHTMLから、widthとheightという固定サイズの属性を正規表現を使って直接削除します。
   2. CSSによる制御の徹底: 削除した上で、コンテナの幅に合わせて100%で表示するためのCSSを適用します。

  この2段階の処理により、SVGは本来持つべきレスポンシブな性質を取り戻し、コンテナのサイズに追従して正しく表示
  されるようになります。

  「文節の解析」セクションの表示を、ご要望の形式に修正します。

  具体的には、以下の変更を行います。

   1. render_clause_highlighted_text 関数内で生成される各節の要約情報から、主語、動詞、導入語の詳細を削除し、節
      のタイプ（主節/従属節）のみを色付きで表示するようにします。
   2. メインの表示部分で、これらの節のタイプを横一列に並べて表示するようにします。

   デバッグ情報をページの一番下にまとめて表示し、それぞれのデバッグ情報に名前を付けます。

  具体的には、以下の変更を行います。

   1. find_clause_elements 関数内の「デバッグ情報:
      検出された節」の表示を、関数から返される値として取得するように変更します。
   2. render_clause_highlighted_text 関数内の「デバッグ情報:
      各トークンの詳細」の表示を、関数から返される値として取得するように変更します。
   3. メインの表示部分で、これらのデバッグ情報をまとめてページの一番下に表示します




   Jyoukyouを読み込んでアプリの実装状況を精査してください。現在解析後、ロジックを見直して無駄がないか、エラ   │
│    ーにならない構造になっているか、セクションごとの処理がはみ出したりはしていないか、などを考えてあなたの  │
│    考えに潜む盲点を洗い出し、重要な前提を問い直し、私が見落としているかもしれない別の視点を提示してコード  │
│    作成してください   


ロジックの再精査と実装評価

  kiroフォルダ内の多数のドキュメント（spaCy-plan、spaCy-roadmap、spaCy-rogicシリーズなど）をすべて精査しまし
  た。これらのドキュメントからは、アプリケーションが目指す一貫した思想が明確に読み取れます。

  設計思想の要点:

   1. 段階的な学習: 単純な主語・動詞の特定から始め、文型、句構造、節構造へと、学習者の理解度に合わせて段階的に深
      い分析機能を提供する。
   2. 視覚的な理解: 専門用語を避けつつも、ハイライト、色分け、ツリー表示、図解などを駆使して、文の構造を直感的に
      「見える化」する。
   3. 深い文法理解: 単に要素を特定するだけでなく、その「役割」（S,V,O,C）、「意味」（動詞の分類）、「関係性」（
      依存関係、修飾関係）、「文脈」（時制、態）まで踏み込んで解説し、応用的な学習を促す。

  現在の`app.py`実装の評価:

  上記の設計思想と照らし合わせた結果、現在の`app.py`の実装は、これまでの計画に非常に忠実であり、適切に進められて
  いると評価できます。

   * 文型判別機能 (`find_sentence_elements`): ロードマップのフェーズ2で計画された通り、S, V, O,
     Cを特定し、文型を判定するロジックが実装されています。これは手法1「文型との連動」に相当します。
   * 句の構造分解機能 (`generate_phrase_tree_html`): 手法6「複雑な主語・動詞句の構造分解」が、CSSによるツリー表
     示という洗練された形で実装されています。主語句と動詞句を分けて表示する点も、ドキュメントの意図通りです。
   * 節の解析機能 (`find_clause_elements`, `render_clause_highlighted_text`):
     手法11「接続詞や関係詞による節の区切り」が実装されており、主節と従属節を色分けして表示することで、複雑な文
     の構造を分かりやすく提示できています。
   * UI/UX: サイドバーに凡例と例文を配置し、メイン画面に解析結果を、詳細情報はエキスパンダー内に表示するという
     構成は、情報が整理されており、ユーザーにとって分かりやすい優れた設計です。
   * コード品質: 前回実施したデバッグコードの削除とエラーハンドリングの強化により、コードの可読性と堅牢性が向上
     しており、今後の機能拡張に向けた良い土台ができています。

  結論として、これまでの実装に大きな問題や計画からの逸脱は見られません。

  次のステップへの提案

  kiroフォルダのロードマップには、まだ実装されていないフェーズ3の機能が明確に示されています。現在の安定したコ
  ードベースを元に、次なるステップとして、これらの応用機能の実装に進むことを提案します。

  特に、以下の機能は現在の実装との親和性が高く、学習効果をさらに高める上で効果的です。

  提案：能動態・受動態の識別機能（手法2）の実装

   * 教育的価値: 主語と動詞の関係性を「動作の主体」と「受け手」という視点から捉え直すことは、文法理解を深める上
     で非常に重要です。
   * 実装の見通し: spaCyの依存関係ラベル（auxpass,
     agent）や品詞タグ（過去分詞）を利用することで、比較的少ないコード量で実現可能です。
   * 具体的な機能:
       1. 解析された文が能動態か受動態かを自動で判別して表示する。
       2. 受動態の場合、「by a boy」のような動作主をハイライトする。
       3. （オプション）能動態と受動態を相互に変換するヒントや練習問題を提供する。



在実装されている「文型判別」「句の構造分解」「節の解析」の3つの機能は、それぞれが異なる角度から英文の
  構造を照らし出す、学習に非常に適した優れた分析手法の組み合わせであると、専門家の視点から評価できます。

  これらの機能がなぜ学習に適しているのか、その理由を個別に、そして相互の関連性から解説します。

  1. 文型判別機能 (S, V, O, Cの特定)

   * 役割: 文の「骨格」を理解させる
   * 学習効果:
       * パターン認識の促進:
         英語の文が、SVOやSVCといった限られた数の基本パターン（文型）で成り立っていることを理解させます。これに
         より、生徒は未知の文に遭遇した際も、既知のパターンに当てはめて構造を推測する力が身につきます。
       * 単語の役割の明確化: 「この単語は文の主語(S)である」「この単語は動詞(V)の目的語(O)である」といったよう
         に、各単語が文の中でどのような「役割」を担っているのかを明確にします。これは、単語の意味を覚えるだけで
         なく、その「使い方」を学ぶ上で不可欠です。
       * 読解のスピードと正確性の向上: 文の骨格であるSVO/SVCなどを素早く見抜くことで、修飾語句に惑わされずに文
         の要点を正確に把握できるようになります。

  2. 句の構造分解機能

   * 役割: 文の「肉付け」を理解させる
   * 学習効果:
       * 修飾関係の可視化: 主語や動詞、目的語などが、単一の単語ではなく、複数の単語からなる「句」で構成されるこ
         とを視覚的に理解させます。「The old man sitting by the
         window」のような長い主語も、中心となる「man」と、それを修飾する「The」「old」「sitting by the
         window」に分解して見ることで、複雑な構造を正しく把握できます。
       * 語順のルールの体得: 形容詞が名詞の前に来る、前置詞句が名詞の後に来るといった、修飾語の語順ルールを直感
         的に学ぶことができます。
       * 表現力の向上: どのような修飾語句を使えば、より具体的で豊かな表現ができるのかを学ぶきっかけとなり、英作
         文の能力向上にも繋がります。

  3. 節の解析機能

   * 役割: 文と文の「繋がり」を理解させる
   * 学習効果:
       * 複文・重文への対応: 一つの長い文が、andやbecause、whoといった接続詞や関係詞によって、複数の「ミニ文（
         節）」が組み合わさってできていることを理解させます。これにより、長文読解への抵抗感をなくします。
       * 情報の階層構造の理解:
         主節（メインの文）と従属節（補足説明の文）の関係性を明確にすることで、文中の情報の重要度を判断する力が
         養われます。例えば、「何が一番言いたいことで、何がそれを補足している情報なのか」を見分ける能力です。
       * 論理的な読解力の育成: 接続詞が示す関係（原因・結果、対比など）を意識することで、文と文の論理的な繋がり
         を考えながら読む習慣がつき、より深いレベルでの読解が可能になります。

  結論：三位一体の優れた分析手法

  これら3つの機能は、単独でも有用ですが、三位一体となって初めて、英文構造の全体像を網羅的に、かつ多角的に学習者
  に提示することができます。

   * ミクロからマクロへ:
     「句の構造分解」で単語のすぐ上の階層（句）を理解し、「文型判別」で文全体の骨格を掴み、「節の解析」で文と文
     の繋がり（複文・重文）を把握するという、ミクロからマクロへの自然な学習フローを形成しています。
   * 相補的な関係: 文型判別だけでは長い主語の内部構造は分かりませんし、節の解析だけでは各節が何文型なのかは分か
     りません。これらの機能が互いに補完し合うことで、学習者は「この文はSVOの第3文型で、そのS（主語）は関係代名
     詞節によって修飾されている」といった、非常に深く、正確なレベルで英文を理解できるようになります。

  したがって、現在の実装ロジックは、学習者が英文法を体系的に、かつ直感的に理解するために非常によく考えられた
  、教育的に価値の高い分析手法であると断言できます。この基盤の上に、次のステップとして能動態・受動態の識別な
  どを加えていくことで、さらに盤石な学習ツールとなるでしょう。

╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│  > ありがとうございます。先ほどの機能ごとの学習効果をたかめられるだけの画面構成、各説明、解説、などになっ  │
│    ているでしょうか？                                                                                      │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

✦ はい、非常に良い質問です。現在の画面構成は、機能ごとにセクションが分かれており、論理的で優れた土台ができてい
  ます。しかし、その学習効果を最大化するという観点から見ると、さらに改善できる点がいくつかあります。

  現在の画面構成と解説を、各機能の学習効果という視点で精査しました。

  現状の評価と改善点

  良い点 (評価できるポイント):

   * 論理的な構造: 「文型判別」→「句の構造分解」→「節の解析」という流れは、ミクロからマクロへと視点が移る、学習
     に適した論理的な順序です。
   * 情報の整理: st.expanderを活用し、詳細情報を隠すことで、一度に表示される情報量を調整し、学習者が混乱しない
     ように配慮されています。
   * 凡例の提示: サイドバーに色分けの凡例があり、視覚的な手がかりの意味を理解しやすくなっています。

  改善の余地がある点 (学習効果をさらに高めるための盲点):

   1. 「So What?（だから何？）」の欠如:
       * 現状: アプリは「何が主語か」「何がSVOか」というWhat（事実）を提示することに長けています。しかし、学習
         者にとっては「なぜそれが主語なのか？」「SVOだと分かると、どんないいことがあるのか？」というSo 
         What?（だから何？）の部分が最も重要です。現状では、その解説が不足しています。
   2. 情報の分断:
       * 現状: 例えば、「文型判別」セクションでSVOと表示されても、下の「ハイライト表示」を見ないと、どの単語がS
         VOなのかが直感的に結びつきにくいです。凡例もサイドバーにあるため、視線の移動が必要です。
   3. 一方的な情報提示:
       * 現状: アプリが解析結果を提示し、学習者はそれを受け取る、という一方向のコミュニケーションになっています
         。学習者が「この単語は何だろう？」と能動的に情報を引き出せるようなインタラクティブ性が不足しています。

  学習効果を最大化するための改善提案

  上記の点を踏まえ、現在のロジックはそのままに、情報の「見せ方」と「解説」を強化することで、学習効果を飛躍的
  に高める具体的な改善案を4つ提案します。

  ---

  提案1：文型判別の直後に「一言サマリー解説」を追加する

  目的: 文型が分かると「だから何？」が分かるようにする。
  実装案: 文型を特定した直後に、その文型がどのような意味を持つのかを平易な言葉で解説する一行を追加します。

  修正イメージ:

  > 文型の判別: SVC (第2文型)
  >
  > 💡 これは「SはCである」と、主語の状態や性質を説明する文の形です。
  >
  > She is a very famous singer.

  この一言があるだけで、生徒は「SVC =
  SとCがイコールの関係」という本質的な理解を得ることができ、丸暗記から脱却できます。

  ---

  提案2：各セクションの冒頭に「学習のゴール」を示す解説を追加する

  目的: これから何を見るのか、それによって何が分かるようになるのかを学習者に意識させる。
  実装案: 各エキスパンダーの直前や直後に、そのセクションの「学習目標」を簡潔に示すキャプションを追加します。

  修正イメージ:

  > 句の構造分解: 主語や動詞がどのような単語の集まりでできているか、その内部構造を詳しく見てみましょう。
  >
  > ▼ 句の構造分解（詳細）

  > 文節の解析: この文が接続詞などでどう区切られ、複数の「ミニ文」で構成されているかを見てみましょう。
  >
  > ▼ 文節の解析

  これにより、学習者は「ただ情報を見ている」のではなく、「句の構造を理解するために見ている」という目的意識を
  持つことができます。

  ---

  提案3：文型要素の凡例とハイライト表示を連携させる

  目的: 凡例と実際の単語を直感的に結びつけ、視線の移動を減らす。
  実装案:
  render_highlighted_text関数を修正し、文型構成要素を表示する際に、実際のハイライトと同じ色を適用します。

  修正イメージ:

  > SVC (第2文型): <span style="background-color: #ADD8E6;">主語 (S)</span> <span style="background-color:
  #FFB6C1;">動詞 (V)</span> <span style="background-color: #D8BFD8;">補語 (C)</span>

  このように、ラベル自体に色をつけることで、サイドバーの凡例を見なくても、どの要素がどの色に対応しているかが
  一目瞭然になります。

  ---

  提案4：ハイライトされた単語に、より詳細なツールチップ解説を追加する

  目的: 一方的な情報提示から、学習者が能動的に情報を引き出せるインタラクティブな体験へ。
  実装案: render_highlighted_text関数とrender_clause_highlighted_text関数を修正し、ハイライトされた単語の<spa
  n>タグのtitle属性に、より詳細な解説を追加します。

  修正イメージ:

   * 主語にカーソルを合わせた場合:
      > title="主語 (S): この文の動作や状態の主体です。"
   * 動詞にカーソルを合わせた場合:
      > title="動詞 (V): 主語の動作や状態を表します。"
   * 目的語にカーソルを合わせた場合:
      > title="目的語 (O): 動詞の動作の対象となるものです。"

  これにより、生徒は気になる単語にカーソルを合わせるだけで、その役割に関する簡単な解説を読むことができ、受動
  的な学習から能動的な探求へとシフトします。

  ---

  まとめ

  現在の実装は技術的に正しく、計画通りに進んでいます。しかし、これらの教育的UX (User Experience) 
  の改善を実装することで、各機能が持つ学習効果を最大限に引き出し、単なる「解析アプリ」から、生徒の思考を促す
  「学習パートナー」へと進化させることができます。

提案内容を実装していきます。

   1. 提案2の実装: 各セクション（句の構造分解、文節の解析）の冒頭に「学習のゴール」を示す解説を追加します。
   2. 提案1 & 3の実装: render_highlighted_text関数を修正し、「一言サマリー解説」のロジックと、文型要素ラベルへの
      色付けを同時に実装します。

  ---

  ステップ1：提案2「学習のゴール」解説の追加

  まず、st.markdownを使って、各エキスパンダーの直前に解説文を追加します。
   句の構造分解セクションの解説文を修正しました。

  次に、「文節の解析」セクションにも同様に解説文を追加します。
   文節の解析セクションの解説文も追加しました。これで提案2の実装は完了です。

  ---

  ステップ2：提案1 & 3「一言サマリー解説」と「文型要素の色付け」の実装

  次に、render_highlighted_text関数を修正します。この関数内で、文型に応じた「一言サマリー解説」を生成し、さら
  に文型要素の凡例にも色を付けます。
  ✦ render_highlighted_text関数の修正が完了しました。

  以上で、提案1, 2, 3の実装はすべて完了です。

   * 提案1（一言サマリー解説）と提案3（文型要素の色付け）は、render_highlighted_text関数内で実装されました。
   * 提案2（学習のゴール解説）は、各セクションのst.markdownを修正することで実装されました。

   現在の画面構成は機能が追加されるにつれて、情報の区切りや階層が分かりにくくなっています。これ
  は学習効果を最大限に引き出す上で、非常に重要な課題です。

  現在の縦長のレイアウトでは、学習者が上から下へと情報を追う中で、「今、自分は何を理解するために、どの情報を見
  ているのか」という目的意識が薄れがちです。

  そこで、現在の優れた解析ロジックはそのままに、画面構成を抜本的に見直し、各分析手法の学習効果を最大化するた
  めの新しいレイアウトを提案します。

  提案：目的別の「タブ形式」レイアウトへの変更

  現在の縦長のレイアウトから、タブ形式のレイアウトへ変更することを提案します。st.tabsを使用することで、各分析
  機能を目的別に明確に分離し、学習者が「今、自分はどの階層の分析を見ているのか」を常に意識しながら学習を進め
  られるようになります。

  新しい画面構成案

  【変更前の構成（現状）】

   1 [解析結果]
   2 - 文型判別
   3 - ハイライトされた文
   4 - ▼ 句の構造分解（詳細）
   5 - ▼ 詳細な依存関係ツリー
   6 - ▼ 文節の解析

  【変更後の構成（提案）】

   1 [解析結果]
   2 [ タブ1: 文の骨格（文型）] [ タブ2: 句の分解 ] [ タブ3: 節の構造 ] [ タブ4: 単語の関係（詳細）]
   3 
   4 ---
   5 （選択されたタブの内容が表示される）
   6 ---

  各タブの役割と学習効果

  タブ1：文の骨格（文型）

   * 表示内容:
       * 文型判別結果（例：SVC 第2文型）
       * 一言サマリー解説（💡 SはCである...）
       * 色付きの文型要素ラベル（S, V, C）
       * 主要素がハイライトされた文全体
   * 学習効果: まず最初に文全体の「骨格」を掴ませます。「この文は、結局のところ『誰が・どうした・何を』という形
     なんだな」という大枠を理解させることが目的です。

  タブ2：句の分解

   * 表示内容:
       * 「句の構造分解」のセクション（主語句と動詞句のツリー表示）
   * 学習効果: 文の骨格を理解した後、次にその構成要素である「主語」や「動詞」が、どのような単語の「肉付け（句）
     」でできているのかを深掘りさせます。タブ1から2への移動は、視点が「全体」から「部分」へと移る体験となり、構
     造の階層性を自然に理解できます。

  タブ3：節の構造

   * 表示内容:
       * 「文節の解析」のセクション（主節・従属節の色分け表示、各節の詳細解説）
   * 学習効果: 単文の構造を理解した後、最後に「文と文の繋がり」（複文・重文）へと視野を広げさせます。接続詞や関
     係詞がどのように「ミニ文（節）」を繋いで、一つの長い文を形成しているのかを学びます。

  タブ4：単語の関係（詳細）

   * 表示内容:
       * 「詳細な依存関係ツリー（上級者向け）」
   * 学習効果: 上級者や、より深く探求したい学習者向けに、全ての単語間の文法的な関係性を網羅した詳細情報を提供し
     ます。普段は他のタブで学習し、必要に応じてこのタブで「答え合わせ」や「探求」ができるようにします。

  この提案のメリット

   1. 明確な情報の分離: 各タブが「文型」「句」「節」という明確な目的を持つため、学習者は混乱しません。
   2. 学習フローのガイド: 「文の骨格 → 句の分解 →
      節の構造」というタブの並び順自体が、英文を理解するための効果的な学習フローを自然にガイドします。
   3. UIの整理と見通しの良さ:
      縦に長くなりがちな情報を整理し、一度に表示される情報量を適切に保つことで、UIがすっきりと見やすくなります。
   4. 拡張性: 将来的に「能動態・受動態」や「時制のチェック」といった新しい機能を追加する際も、新しいタブとして整
      理しやすく、拡張性が高いです。

✦ タブ形式のレイアウトへの変更が完了しました。

  これで、解析結果が「文の骨格（文型）」「句の分解」「節の構造」「単語の関係（詳細）」という4つのタブに整理さ
  れ、より目的意識を持って学習を進められるようになったはずです。

  「単語の依存関係（詳細）」タブに表示されている図（依存関係ツリー）が示す情報について、詳しくご説明しま
  す。

  これは、文を構成する全単語の間の「文法的な関係性」と「階層構造」を、矢印を使って視覚的に表現したものです。
  いわば、文の「設計図」や「組織図」のようなものです。

  この図を見ることで、以下の2つの重要な情報が分かります。

  1. 各単語の「係り受け」の関係

  図の中の矢印は、単語と単語の「係り受け」の関係を示しています。

   * 矢印の根元: 修飾したり、説明したりする「子」の単語です。
   * 矢印の先: 修飾されたり、説明されたりする「親」の単語（headと呼ばれます）です。

  例えば、"The cat sat on the mat." という文では、

   * The → cat: 「The」が「cat」を修飾している（どの猫かを特定している）ことを示します。
   * cat → sat: 「cat」が動詞「sat」の主語であることを示します。
   * on → sat: 前置詞句「on the mat」が、動詞「sat」を修飾している（どこに座ったか）ことを示します。
   * mat → on: 「mat」が前置詞「on」の目的語であることを示します。

  このように、全ての単語が何らかの形で他の単語と結びついて文が成り立っていることが分かります。

  2. 各単語の「文法的な役割」

  矢印の下に書かれているラベル（例: nsubj, det,
  pobj）は、その係り受けがどのような「文法的な役割」を持つかを示しています。

   * `nsubj`: 名詞的主語 (Nominal Subject) - 動詞の主語であることを示します。
   * `ROOT`: 文の根 (Root) - 文全体で最も中心的となる単語（通常は主動詞）であることを示します。全ての矢印を辿っ
     ていくと、最終的にこのROOTに行き着きます。
   * `det`: 限定詞 (Determiner) - 名詞を特定する単語（the, a, myなど）であることを示します。
   * `prep`: 前置詞句 (Prepositional Phrase) - 前置詞で始まる句であることを示します。
   * `pobj`: 前置詞の目的語 (Object of Preposition) - 前置詞の目的語であることを示します。

  学習上の価値

  この「単語の依存関係（詳細）」タブは、他のタブで学んだことの「答え合わせ」や「より深い探求」に非常に役立ちま
  す。

   * 「なぜ、この単語が主語なの？」への答え: 「文の骨格」タブで "cat" が主語だと分かった後、この詳細タブで
     "cat" から動詞 "sat" へ nsubj というラベルの矢印が伸びているのを見ることで、「spaCyがnsubjという文法関係を
     認識したから、この単語を主語だと判断したんだな」という論理的な裏付けを理解できます。
   * 修飾関係の完全な理解: 「句の分解」タブでは主語句や動詞句といった大きな塊を見ますが、この詳細タブでは、その
     句の中のさらに細かい単語一つ一つが、どのように核となる単語に結びついているのかを正確に追うことができます。
   * 複雑な文の構造分析: 関係代名詞節や倒置構文など、複雑な文の構造も、この依存関係ツリーを見れば、どの単語がど
     の単語にどういう役割で結びついているのかが一目瞭然になります。

  総じて、このタブは他のタブよりも専門的で情報量が多いですが、文の構造を最も正確かつ網羅的に表現しているため
  、上級者や、文法の仕組みを根本から理解したい学習者にとって、非常に価値の高い情報源となります。

╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│  > 単語の依存関係（詳細）」タブに表示されている図（依存関係ツリー）の役割分かりました。ただ1.                │
│    各単語の「係り受け」の関係も2. 各単語の「文法的な役割」も今こうやって説明してもらえなければ、矢印の意味や │
│     nsubj が主語ですなんてことは図を提示してだけでは分かりませんでした。これらの解説や意味をいれたページ作り │
│    になっていてほしい                                                                                        │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

✦ おっしゃる通りです。専門的な図を提示するだけでは、学習者、特に小中高生にとっては「ただの複雑な図」にしか見え
  ず、その価値が全く伝わりません。ご指摘は非常に的確で、教育用アプリとして致命的な欠陥を防ぐための重要な改善点
  です。

  「単語の依存関係（詳細）」タブが、自己説明的（self-explanatory）で、それ自体が学習教材として機能するように
  、解説と意味を追加する修正を提案します。

  提案：凡例と解説を追加し、「読める図」に進化させる

  現在の「単語の依存関係（詳細）」タブを、以下の2つの要素を追加して改善します。

   1. インタラクティブな凡例の追加:
      図の上または下に、主要な依存関係ラベル（nsubj, dobj, ROOTなど）の凡例を一覧で表示します。
   2. 図の読み方のガイドを追加:
      凡例のさらに上、タブの冒頭部分に、この図が何を表しているのか、矢印やラベルをどう読み解けば良いのかを簡
  潔に説明するガイドを追加します。

  ---

  新しい「単語の依存関係（詳細）」タブのレイアウト案

  【タブ4：単語の関係（詳細）】

  > この図の読み方ガイド
  >
  > この図は、文を構成する全単語の「係り受け」の関係を示した設計図です。
  >
  >    矢印:* 単語と単語の文法的な繋がりを表します。矢印の根元が、矢印の先の単語を修飾・説明しています。
  >    ラベル:*
  矢印の下にあるラベル（nsubjなど）は、その繋がりがどのような「文法的な役割」を持つかを示しています。
  >
  > すべての矢印を辿っていくと、文の中心であるROOT（根）に行き着きます。
  >
  > ---
  >
  > 【依存関係ツリーの図】
  >
  > ---
  >
  > 凡例：主な依存関係ラベルの意味
  >
  >    nsubj:* 名詞的主語 (文の動作や状態の主体)
  >    ROOT:* 文の根 (文全体で最も中心となる動詞)
  >    dobj:* 直接目的語 (動詞の動作の対象)
  >    iobj:* 間接目的語 (動作の対象を受け取る相手)
  >    attr:* 補語 (名詞的) (主語や目的語の状態を説明する名詞)
  >    acomp:* 補語 (形容詞的) (主語や目的語の状態を説明する形容詞)
  >    det:* 限定詞 (名詞を特定する a, the など)
  >    amod:* 形容詞修飾語 (名詞を修飾する形容詞)
  >    advmod:* 副詞修飾語 (動詞や形容詞を修飾する副詞)
  >    prep:* 前置詞句
  >    pobj:* 前置詞の目的語
  >    aux:* 助動詞
  > *   ... (その他、主要なものをいくつか)

  ---

  この改善による学習効果

   * 解読能力の付与:
     このガイドと凡例があることで、生徒は初めて見る依存関係ツリーでも、自力でその意味を読み解く方法を学べます。
   * 専門用語への橋渡し: nsubjが「名詞的主語」であるという対応関係を明示することで、専門的な文法用語への抵抗感
     をなくし、自然な形で知識を習得できます。
   * 探求学習の促進:
     「この矢印のconjってどういう意味だろう？」と凡例で確認する、といった能動的で探求的な学習態度を促します。
   * 自己完結した学習体験: このタブだけで情報が完結するため、学習者は外部のサイトで意味を調べる必要がなく、アプ
     リ内での学習に集中できます。

図の下が切れてしまうのですね。st.imageに切り替えたことで横幅の問題は解決しましたが、
  高さが自動調整されていないようです。

  これは、st.imageがSVGの高さをコンテナに合わせるようにはデフォルトで動作しないために発生しています。

  この問題を解決するため、SVGの高さをコンテナの幅に応じて適切に調整する、最終的なアプローチを試みます。

  修正方針:

   1. SVGの`viewBox`属性を活用: SVGにはviewBoxという属性があり、これを使うとSVG内部の座標系と表示サイズのアスペ
      クト比（縦横比）を制御できます。displacyが生成するSVGには、このviewBoxが設定されています。
   2. CSSでアスペクト比を維持: SVGのwidthを100%に設定し、heightをautoに設定することで、SVGはコンテナの横幅いっぱ
      いに広がりつつ、viewBoxで定義された元々の縦横比を維持して高さが自動的に調整されるようになります。
   3. `st.markdown`の再利用: このCSSを適用するためには、st.imageではなく、再度st.markdownを使ってHTMLとして埋め
      込む方法に戻す必要があります。しかし、今回はSVGの属性を削除するのではなく、CSSで上書きする方法を取るため、
      以前とは異なるアプローチになります。


       現在のアプリは、ロードマップのフェーズ1（主語と動詞の見える化）とフェーズ2（文型判別、句の構造分解、節の解
  析）の主要な機能が実装され、UIも学習効果を最大化するようにタブ形式で整理されました。

  次に、ロードマップのフェーズ3「実践と応用 - 
  文法と表現の『使いこなし』へ」の機能実装に進むことを提案します。

  このフェーズの最初のステップとして、能動態・受動態の識別機能（手法2）の実装に着手するのはいかがでしょうか。

   * 教育的価値: 主語と動詞の関係性を「動作の主体」と「受け手」という視点から捉え直すことは、文法理解を深める上
     で非常に重要です。
   * 実装の見通し: spaCyの依存関係ラベル（auxpass,
     agent）や品詞タグ（過去分詞）を利用することで、比較的少ないコード量で実現可能です。


     ロードマップのフェーズ3「実践と応用 - 文法と表現の『使いこなし』へ」の機能実装に進みます。

  最初のステップとして、能動態・受動態の識別機能（手法2）を実装します。

  この機能は、文が能動態か受動態かを判別し、その結果をUIに表示します。

  ---

  実装手順

   1. `find_sentence_elements`関数の拡張:
       * この関数内で、文の態（能動態/受動態）を判別するロジックを追加します。
       * elements辞書に"voice"（態）の情報を追加し、関数が返す値にvoiceを含めます。
   2. UIの更新:
       * 「文の骨格（文型）」タブ内に、判別された態（能動態/受動態）を表示するセクションを追加します。

  まず、find_sentence_elements関数を修正し、態の判別ロジックを追加します。

  
  「The ball was kicked by the
  boy.」で主語と動詞が特定できない問題、承知いたしました。

  これは、find_sentence_elements関数内の主語特定ロジックが、受動態の文構造（特にbe動詞がROOTになる場合）に完
  全に対応できていなかったことが原因と考えられます。nsubjがROOT動詞の直接の子ではない場合に、主語を見落として
  しまう可能性があります。

  この問題を解決するため、find_sentence_elements関数を修正し、主語の特定ロジックを強化します。

  ---

  修正方針

   1. 主語の特定ロジックの強化: main_verb_candidate（ROOT動詞）の直接の子だけでなく、そのsubtree（サブツリー、つ
      まりその動詞に依存する全ての単語）の中からnsubjを探すように変更します。これにより、ROOTがAUX（be動詞）で、
      実際の動詞がその子孫にある場合でも、主語を正しく見つけられるようになります。
   2. 受動態判別ロジックの調整: AUXがROOTの場合の受動態判別をより明確にします。
   3. 目的語の特定条件の調整:
      受動態の文では直接目的語（dobj）は存在しないため、能動態の場合のみdobjとiobjを探すようにします。

  それでは、find_sentence_elements関数全体を以下の内容に置き換えます。

  ✦ find_sentence_elements関数を修正しました。

   * 主語の特定ロジックを強化し、ROOT動詞のsubtree全体からnsubjを探すようにしました。
   * 受動態の判別ロジックを調整し、AUXがROOTの場合も考慮するようにしました。
   * 能動態の場合のみdobjとiobjを探すように条件を追加しました。

     修正方針

   1. `ROOT`動詞の特定をより柔軟に: 受動態の場合、be動詞がROOTになることが多いため、main_verb_candidateをROOT動
      詞として特定した後、そのsubtree内に実際の動作を表す動詞（過去分詞）があるかをチェックします。
   2. 主語の特定ロジックの調整: ROOT動詞のsubtreeからnsubjを探すのは正しいですが、そのnsubjがROOT動詞に直接依存
      しているか、あるいはauxpassを介して依存しているかを確認します。
   3. 受動態判別ロジックの簡素化: be動詞がROOTで、その子孫に過去分詞の動詞があり、その過去分詞がauxpassとしてbe
      動詞に依存している、というパターンで受動態を判別します。

  それでは、find_sentence_elements関数全体を以下の内容に置き換えます。

  en_core_web_mdモデルをダウンロードします。

  このコマンド python -m spacy download en_core_web_md は、spaCyの英語モデルである en_core_web_md
  をローカル環境にダウンロードします。これにより、より大規模で高精度なモデルが利用可能になり、英文解析の精度
  が向上する可能性があります。
 これで、en_core_web_mdモデルへの切り替えと関連ファイルの更新が完了しました。

 
  